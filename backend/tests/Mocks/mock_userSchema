const mongoose = require("mongoose");
const moment = require("moment");

const mock_userDatabse = require("./mock_Database.js");

class mock_userSchema {

    static required_attributes = ["username", "password", "email"];

    // ---------- ATTRIBUTES ---------- //

    username;               /** @type {String} The username of the user **/
    #_lc_username;          /** @type {String} Lowecase version of this.username **/
    password;               /** @type {String} The password of the user **/
    email;                  /** @type {String} The email of the user **/   
    first_name = null;      /** @type {String} The first name of the user **/
    last_name = null;       /** @type {String} The last name of the user **/
    age = null;             /** @type {Number} The age of the user **/

    #_id = null;            /** @type {Number} The id of the user **/

    #_profile = null;        /** @type {User.Profile} The public profile of the user **/

    #_spotify_token = null;  /** @type {String} The user's spotify token **/

    #_session_id = null;     /** @type {Number} The user's session ID **/
    #_session_date = null;   /** @type {Date} The date of the user's session **/

    // ---------- CONTSTRUCTOR ---------- //

    constructor(
        username, password, email, first_name = null, last_name = null, age = null
    ) {
        this.username = username;
        this.password = password;
        this.email = email;
        this.first_name = first_name;
        this.last_name = last_name;
        this.age = age;

        this.#_id = mock_userSchema.#_generateID.next().value;
    }

    static fromJSON(JSON) {
        return new mock_userSchema(JSON.username, JSON.password, JSON.email, JSON.first_name, JSON.last_name, JSON.age);
    }

    // ========== OBJECT METHODS ========== //

    // ---------- GETTERS / SETTERS ---------- //

    /**
        @param {String} username
    **/
    set username(username) {
        this.username = username;
        this.#_lc_username = this.username.toLowerCase();
    }
    
    /**
        @returns {String} lowercase username
    **/
    get _lc_username() {
        return this.#_lc_username;
    }

    /**
        @param {String} password
    **/
    set password(password) {
        this.password = password;
        return 0;
    }

    /**
        @param {String} email
    **/
    set email(email) {
        this.email = email;
    }

    /**
        @param {String} first_name
    **/
    set first_name(first_name) {
        this.first_name = first_name;
    }

    /**
        @param {String} last_name
    **/
    set last_name(last_name) {
        this.last_name = last_name;
    }

    /**
        @param {Number} age
    **/
    set age(age) {  
        this.age = age;
    }

    /**
        @returns {mock_userSchema.Profile} the user profile
    **/
    get profile() {
        return this.#_profile;
    }

    /**
        @returns {Number} session ID
    **/
    get session_id() {
        return this.#_session_id;
    }

    /** 
        @returns {Date} session date
    **/
    get session_date() {
        return this.#_session_date;
    }

    /**
        @param {String} spotify_token new spotify token
    **/
    set spotify_token(spotify_token) {
        this.#_spotify_token = spotify_token;
    }

    /** 
        @returns {String} user's spotify token
    **/
    get spotify_token() {
        return this.#_spotify_token;
    }

    // ---------- SESSION RELATED METHODS ----------

    /**
        Generates a new session for the user.
    **/
    generateSession() {
        this.#_session_id = mock_userSchema.generateSessionID();
        this.#_session_date = Date.now();
    }

    /** 
        Ends the user's session
    **/
    endSession() {
        this.#_session_id = null;
        this.#_session_date = null;
    }

    /**
        @param {Number} session_id the session ID to validate against user's session
        @param {Date} session_date the session date to validate against user's session
        @returns {boolean} true if the session ID is valid, false otherwise
    **/
    validateSession(session_id, session_date = null) {
        if (this.session_id != session_id) { return false; }

        if (session_date == null) { session_date = Date.now(); }
        if (this.session_date == null || moment(session_date).diff(moment(this.session_date), 'days') > 1.0) {
            this.endSession();
            return false;
        }

        return true;
    }


    // ========== STATIC METHODS ========== //

    // ---------- SCHEMA METHODS ---------- //
    static #_generateID = function* () {
        let id = 0;
        while (true) {
            yield id;
            id++;
        }
    }()

    // ---------- VALIDATION ---------- //

    /**
            @param {String} username username to check the validity of
            @param {mongoose.Model} database database to check for username validity in
            @returns {boolean} true if the username is valid, otherwise false
        **/
    static async validateUsername(username, model) {
        if (await model.findOne({ _lc_uname: username.toLowerCase() })) { return false; }
        return true;
    }

    /**
        @param {String} password password to validate
        @param {mongoose.Model} database database to validate password in
        @returns {boolean} true if the password is valid, otherwise false
    **/
    static async validatePassword(password, model) {
          return true;  
    }

    /**
            @param {String} email emsil to check the validity of
            @param {mongoose.Model} database database to check for email validity in
            @returns {boolean} true if the email is valid, otherwise false
        **/
    static async validateEmail(email, model) {
        if (await model('UserAccount').findOne({ _lc_uname: email })) { return false; }
        return true;
    }

    // ---------- SESSION RELATED METHODS ---------- //

    /**
        @returns {Number} a randomly generated session ID
    **/
    static generateSessionID() {
        return Math.floor(Mathh.random() * 10_000_000);
    }

    /**
        @param {Number} session_id the session ID to validate against expected session
        @param {Date} session_date the session date to validate against expected session
        @param {Number} expected_session_id the expected session id
        @param {Date} expected_session_date the expected session date
        @returns {boolean} true if the session is valid, false otherwise 
    **/
    static validateSession(session_id, session_date, expected_session_id, expected_session_date) {
        if (expected_session_id != session_id) { return false; }

        if (expected_session_date == null || moment(session_date).diff(moment(expected_session_date), 'days') > 1.0) { return false; }

        return true;
    }
}


mock_userSchema.Profile = class {
    // things the user's public profile (may) have
    #profile_description;
    #profile_image;
}

exports = {
    mock_userSchema: mock_userSchema
};